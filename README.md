



[![Build Status](https://travis-ci.org/AbdullahTaher93/TFM.svg?branch=master)](https://travis-ci.org/AbdullahTaher93/TFM) [![Language](https://img.shields.io/badge/laguage-java-green.svg)](https://www.java.com/)

# Cryptanalysis Ciphertext Based Genetic Algorithms

## ABSTRACT  
Cryptanalysis is breaking the ciphertext(codes) to find the
plaintext (original text) .There are many tools used in the cryptanalysis.Genetic algorithm(GA).Is an optimization search
tool to find the best solution.In this project ,Genetic algorithm(GA) used as a cryptanalysis tool to search the decryption key for obtaining the plaintext from the ciphertext.When the ciphertext generated by the transpositioncipher.

## Introduction
Cryptanalysis is the technique of deriving the original message from the cipher text without any prior knowledge of secret key or the erivation of key from the cipher text. A general technique for cryptanalysis, applied to all cryptographic algos is to try all the possible keys until the correct key is matched, it is known as exhaustive key search. 

A symmetric key cipher, especially a stream cipher is assumed secure, if the computational capability required for breaking the cipher by best-known attack is greater than or equal to exhaustive key search. 
Cryptanalysis is the science of making encrypted data unencrypted use convert cipher text to plaintext because cryptanalysis used to convert plaintext to cipher text and used cryptanalysis Return to plaintext or clear text or original text cryptanalysis is used to break codes by finding weaknesses. There are many techniques used in the cryptanalysis. This project used the genetics algorithm.

The genetic algorithm is a search algorithm based on the mechanics of natural selection and natural genetics The genetic algorithm belongs to the family of evolutionary algorithms, along with genetic programming, Evolution strategies and evolutionary programming. The set of operators usually consists of mutation, crossover and selection,

Cryptanalysis is the technique of extracting useful information about the key by observing the plaintext and cipher text using cryptanalysis   try to break the secrecy provided by the cipher. There is no fixed method for cryptanalysis and every cipher is a different challenge to the attacker and hence demands different insight to attack  In this chapter, explained the history of cryptanalysis, the technology of cryptanalysis, transposition cipher, and description genetics algorithm (GA).

## Cryptanalysis
Cryptanalysis are the basic techniques on block cipher and till today, many cryptanalytic attacks are developed based on these. The cryptanalysis return cipher text to clear text  (or original text) by different methods to find the decryption  key, in other words, cryptanalysis is a method to reveal the key by the Receiver to transform cipher text to plaintext (or original text)

![Cryptanalysis](https://github.com/AbdullahTaher93/TFM/blob/master/images/Cryptanalysis.png)

## Implementation

genetic algorithm (GA) can be used for  obtaining  the decryption key to break ciphertext and transfer ciphertext message to plaintext message (readable message). GA is a search tool to insure high probability of finding a solution by decreasing the amount of time in the key space searching. GA consists of many operations: Evaluation fitness, Selection, Crossover, and Mutation. In Figure below Flowchart of proposed method of cryptanalysis.

![Flowchart](https://github.com/AbdullahTaher93/TFM/blob/master/images/Flowchart.png)


### 1- Initialization (Population)
Population is a subset of solutions in the current generation. It can also be defined as a set of chromosomes. There are several things to be kept in mind when dealing with GA population −

* The diversity of the population should be maintained otherwise it might lead to premature convergence.

* The population size should not be kept very large as it can cause a GA to slow down, while a smaller population might not be enough for a good mating pool. Therefore, an optimal population size needs to be decided by trial and error.

The population is usually defined as a two dimensional array of – size population, size  x , chromosome size.

There are two primary methods to initialize a population in a GA. They are −

* Random Initialization − Populate the initial population with completely random solutions.

* Heuristic initialization − Populate the initial population using a known heuristic for the problem

So with our problem we will use the first method which is (Random Initialization) generate a pool of random keys (size population), when the length of the key is N digits (chromosome size)  and the pool size is M keys(size population). Also, The key condition is random and non-repetitive in each key. These keys are changeable  by the other stages of GA and the better one used in derivation the plaintext.

### 2- Transposition Cipher
The transposition cipher is rearranged (change position only) the characters in the message but not change the characters. Transposition cipher have a pool of keys and ciphertext  that rearranged the ciphertext  for M times depended on the pool of keys. The output of transposition cipher saved in array of M locations we can called it  "plaintext_array".

A simple transposition or permutation cipher works by breaking a message into fixed size blocks, and then permuting the characters within each block according to a fixed permutation, say P. The key to the transposition cipher is simply the permutation P. So, the transposition cipher has the property that the encrypted message contains all the characters that were in the plaintext message. In other words, the unigram statistics for the message are unchanged by the encryption process. The size of the permutation is known as the period. Let's consider an example of a transposition cipher with a period of ten 10, and a key P={7,10,4,2,8,1,5,9,6,3}. In this case, the message is broken into blocks of ten characters, and after encryption the seventh character in the block will be moved to position 1, the tenth moved character in the block will be moved to position 2, the forth is moved to position 3, the second to position 4, the eighth to position 5, the first to position 6, the fifth to the position 7, the ninth to the position 8, the sixth to the position 9 and the third to position 10.

In  Table below shows the key and the encryption process of the previously described transposition cipher. It can be noticed that the random string "X" was appended to the end of the message to enforce a message length, which is a
multiple of the block size.

![Transposition](https://github.com/AbdullahTaher93/TFM/blob/master/images/Transposition.png)

### 3- Evaluation Fitness 
Fitness is evaluated based on the biagrams (sequence of two letters) frequency in the decrypted cipher text and Trigrams (sequence of three letters) frequency in the decrypted cipher text. the tables below illustrated the most popular biagrams and Trigrams  in English language. Triagrams and diagrams   are   computationally expensive the fitness calculation.  Fitness function is as shown below equation:

     Fitness function= β. ∑| (K (bi, j) −D (bi, j))|+   γ. ∑| (K (ti, j) −D (ti, j))|

Where β and γ are a constant
* K represents Known English Language
* D represents Decrypted the message
* Bi represents the bigram (two letter sequence).
* Ti represents the triagram (three letter sequence).

![TiBi](https://github.com/AbdullahTaher93/TFM/blob/master/images/TIBI.png)


### 4- Selection operation
In this operation, selection (choosing) the best keys only. The best key which has the high value of fitness. In the proposed work select only M/2 keys which have the high fitness.  To perform the selection operation nedded a sorting function to sort pool of keys from high fitness to low fitness.


### 5- Crossover Operation
In this operation, after selecting the best M/2 keys by the selection operation, applying the crossover operation to obtain the remainder M/2 keys. In the crossover operation, each key performs a crossover to obtain a new key with the condition non-primitive keys. After the crossover operation, a new pool of keys obtaining, these are called "new population".

#### 5.1 One Point Crossover
In this one-point crossover, a random crossover point is selected and the tails of its two parents are swapped to get new off-springs.

![one_point_crossover](https://github.com/AbdullahTaher93/TFM/blob/master/images/one_point_crossover.png)

#### 5.2 Multi Point Crossover
Multi point crossover is a generalization of the one-point crossover wherein alternating segments are swapped to get new off-springs.

![multi_point_crossover](https://github.com/AbdullahTaher93/TFM/blob/master/images/multi_point_crossover.png)

#### 5.3 Uniform Crossover
In a uniform crossover, we don’t divide the chromosome into segments, rather we treat each gene separately. In this, we essentially flip a coin for each chromosome to decide whether or not it’ll be included in the off-spring. We can also bias the coin to one parent, to have more genetic material in the child from that parent.
![uniform_crossover](https://github.com/AbdullahTaher93/TFM/blob/master/images/uniform_crossover.png)

#### 5.4 Davis’ Order Crossover (OX1)
OX1 is used for permutation based crossovers with the intention of transmitting information about relative ordering to the off-springs. It works as follows −

Create two random crossover points in the parent and copy the segment between them from the first parent to the first offspring.

Now, starting from the second crossover point in the second parent, copy the remaining unused numbers from the second parent to the first child, wrapping around the list.

Repeat for the second child with the parent’s role reversed.

![david_order_crossover](https://github.com/AbdullahTaher93/TFM/blob/master/images/david_order_crossover.png)


### 6- Mutation Operation 
In this operation, applying the mutation operation for the new population.  To perform the mutation operation, two random numbers  generated  such as R1, and R2 representing  two positions in each key then swap between value of the position R1 and the value of the position R2.  Repeat this operation for all keys in the "new population" pool.

### 7- Display the Round No. and Plaintext
In this operation, display the plaintext (clear text is unencrypted information) for storage or transmission after decrypted the ciphertext. Also, display the Round number that obtaining the plaintext from ciphertext.

## Programming
### 1 Population Step
the first class to start is [Population.java](https://github.com/AbdullahTaher93/TFM/blob/master/src/cryptanalysis_gas/Population.java) in this class we created the Population which represents a set of chromosomes and each chromosome has the same length so, Population class has one constructor  and many methods that follow:

#### 1.1 Population Constructor 
   Population(int No_OF_keys,int length_OF_key)
   * No_OF_keys: No. of chromosomes
   * length_OF_key: length of the chromosome
   under this Constructor, we can call all of the methods to create our population and show it.
   First method is [IF_KEY_EXIST](https://github.com/AbdullahTaher93/TFM/blob/5df7a0d35278b1491faf0b8c8891b0b6d2210aaf/Cryptanalysis_GAs/src/cryptanalysis_gas/Population.java#L24) this method will generates set of numbers between 1 and length of chromosome without repeat numbers (non-repetitive) and randomly, the method to ensure there are no duplicate number called [check](https://github.com/AbdullahTaher93/TFM/blob/5df7a0d35278b1491faf0b8c8891b0b6d2210aaf/Cryptanalysis_GAs/src/cryptanalysis_gas/Population.java#L41) which has to parameters array of numbers that saved before and new number which will save in same array, and return true or false (if this new number exist in array of number will return false in another case will return true and save it) after get more then 2 chromosomes we have to check if there are duplicate chromosomes this step done with this method which calls [check_row](https://github.com/AbdullahTaher93/TFM/blob/5df7a0d35278b1491faf0b8c8891b0b6d2210aaf/Cryptanalysis_GAs/src/cryptanalysis_gas/Population.java#L52) which receive all of chromosomes that saved before and new chromosome after that will compare between them to find if there are duplicated between these chromosomes, then will return false if there are no chromosomes duplicated and save it if not will repeat the step of creating new chromosome.

   finally, we can call [Print](https://github.com/AbdullahTaher93/TFM/blob/5df7a0d35278b1491faf0b8c8891b0b6d2210aaf/Cryptanalysis_GAs/src/cryptanalysis_gas/Population.java#L75) method to show all of the chromosomes

   ##### Experimental results
     No. of chromosomes is: 12
     length of chromosome is: 6 
     
     ![Chros12_6](https://github.com/AbdullahTaher93/TFM/blob/master/images/Chros12_6.png)

     No. of chromosomes is: 16
     length of chromosome is: 8

     ![Chros16_8](https://github.com/AbdullahTaher93/TFM/blob/master/images/Chros16_8.png)




